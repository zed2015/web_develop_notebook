# 数据密集型应用设计

## 分布式数据

## MYISAM 表级锁
- table read lock
    - select 前给涉及的表加读锁
    - 其它线程不能写
- table write lock
    - update delete insert 前会加写锁
    - 其它线程不能读取
- 查看锁的状态 `show status like 'table%';`
    - Table\_locks\_immediate：产生表级锁定的次数；
    - Table\_locks\_waited：出现表级锁定争用而发生等待的次数；
## innodb 行级别锁
> https://www.cnblogs.com/sessionbest/articles/8689071.html
- 对于更新操作会自动加上排他锁
- select lock in share mode, 其它事务不能更新
- select for update 排他锁, 其它的事务不能读取
- 注意:
    - 在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。
    - 由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。
    - 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。
    - 即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。

### 事务

- 读已提交
    - 特征：
        - 从数据库读时， 只能看到已经提交的数据（没有脏读)
        - 写入数据是，只能覆盖已经写入的数据（没有脏写)
    - 解决：
        - 可以使用行锁，但严重影响性能，数据会记住旧的以提交值，及当前持有写入锁的事务设置的新值。
        - 数据库使用行锁
    - 遗留问题：
        - 不可重复读,读取偏差

- 快照隔离和重复读
    - 解决问题，读取偏差在下列情况下是不允许的
        - 备份, 包含就的部分和一些新的部分，如果从这样的备份中恢复，那么不一致就会变成永久
        - 分析查询和完整性检查
    - 实现:
        - 读不阻塞写，写不阻塞读
        - 多版本并发控制 MVCC
        - 读已提交对每一个查询使用单独的快照，而快照隔离对整个事务使用相同的快照
        - 当一个书屋开始时，它被赋予唯一永久增长的事务ID， 40亿次
        - 行都有一个created_by 字段，其中包含该行插入到列表中的事务ID， 还有一个delete_by字段，最初为空，当确定没有事务可以在访问到已删除数据，就会被移除
        > 在postgresql中，created_by是xmin， deleted_by 是xmax, update操作内部翻译为delete 和insert
    - 一致性快照的可见性规则
        - 每次事务开始时， 数据库列入当时尚未提交的事务清单，即使提交了，这些事务的写入也都会被忽略
        - 被中止事务所执行的任务和写入都被忽略
        - 较晚的事务ID被忽略
        - 所有其他写入，对应用都是可见的
    - 总结如下条件
        - 读事务开始时，创建该对象的事务已经提交
        - 对象未被标记为删除，如果标记为删除，请求删除的事务在读事务开始时尚未提交。
- 原子写
    - 获取排它锁
    - 游标稳定性
    - orm框架很容易意外执行不安全的读取-修改-写入
    - select for update
- 自动检测丢失的更新
    - 事务管理器检测到丢失更新，中止事务并强制重试
    - postgresql 可以检测，mysql/innodb不会检测

- 比较并设置

- 写入偏差与幻读
    - 真正的可序列化，
    - 显示锁定事务所依赖的行, select for update, 当插入时就不起作用了
    - 例子：
        - 会议室预订
        - 多人游戏
        - 抢注用户名
        - 防止双重开支

    - 一个事务中写入改变另一个事务的搜索查询的结果，被称为幻读，快照隔离避免了只读查询中的幻读，

- 物化冲突
    - 最后的手段

- 可序列化
    - 串行执行
        - RAM足够便宜， redis
 





