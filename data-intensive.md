# 数据密集型应用设计

## 分布式数据

### 事务

- 读已提交
    - 特征：
        - 从数据库读时， 只能看到已经提交的数据（没有脏读)
        - 写入数据是，只能覆盖已经写入的数据（没有脏写)
    - 解决：
        - 可以使用行锁，但严重影响性能，数据会记住旧的以提交值，及当前持有写入锁的事务设置的新值。
        - 数据库使用行锁
    - 遗留问题：
        - 不可重复读,读取偏差

- 快照隔离和重复读
    - 解决问题，读取偏差在下列情况下是不允许的
        - 备份, 包含就的部分和一些新的部分，如果从这样的备份中恢复，那么不一致就会变成永久
        - 分析查询和完整性检查
    - 实现:
        - 读不阻塞写，写不阻塞读
        - 多版本并发控制 MVCC
        - 读已提交对每一个查询使用单独的快照，而快照隔离对整个事务使用相同的快照
        - 当一个书屋开始时，它被赋予唯一永久增长的事务ID， 40亿次
        - 行都有一个created_by 字段，其中包含该行插入到列表中的事务ID， 还有一个delete_by字段，最初为空，当确定没有事务可以在访问到已删除数据，就会被移除
        > 在postgresql中，created_by是xmin， deleted_by 是xmax, update操作内部翻译为delete 和insert
    - 一致性快照的可见性规则
        - 每次事务开始时， 数据库列入当时尚未提交的事务清单，即使提交了，这些事务的写入也都会被忽略
        - 被中止事务所执行的任务和写入都被忽略
        - 较晚的事务ID被忽略
        - 所有其他写入，对应用都是可见的
    - 总结如下条件
        - 读事务开始时，创建该对象的事务已经提交
        - 对象未被标记为删除，如果标记为删除，请求删除的事务在读事务开始时尚未提交。
- 原子写
    - 获取排它锁
    - 游标稳定性
    - orm框架很容易意外执行不安全的读取-修改-写入
    - select for update
- 自动检测丢失的更新
    - 事务管理器检测到丢失更新，中止事务并强制重试
    - postgresql 可以检测，mysql/innodb不会检测

- 比较并设置

- 写入偏差与幻读
    - 真正的可序列化，
    - 显示锁定事务所依赖的行, select for update, 当插入时就不起作用了
    - 例子：
        - 会议室预订
        - 多人游戏
        - 抢注用户名
        - 防止双重开支

    - 一个事务中写入改变另一个事务的搜索查询的结果，被称为幻读，快照隔离避免了只读查询中的幻读，

- 物化冲突
    - 最后的手段

- 可序列化
    - 串行执行
        - RAM足够便宜， redis
 





